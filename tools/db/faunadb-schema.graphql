directive @embedded on OBJECT

directive @collection(name: String!) on OBJECT

directive @index(name: String!) on FIELD_DEFINITION

directive @resolver(
  name: String
  paginated: Boolean! = false
) on FIELD_DEFINITION

directive @relation(name: String) on FIELD_DEFINITION

directive @unique(index: String) on FIELD_DEFINITION

# 'Category' input values
input CategoryInput {
  archived: Boolean!
  title: String!
  type: CategoryType!
  externalUrl: String
  paymentFrequency: PaymentFrequency
}

scalar Date

type Mutation {
  # Partially updates an existing document in the collection of 'Category'. It only modifies the values that are specified in the arguments. During execution, it verifies that required fields are not set to 'null'.
  partialUpdateCategory(
    # The 'Category' document's ID
    id: ID!

    # 'Category' input values
    data: PartialUpdateCategoryInput!
  ): Category

  # Partially updates an existing document in the collection of 'Transaction'. It only modifies the values that are specified in the arguments. During execution, it verifies that required fields are not set to 'null'.
  partialUpdateTransaction(
    # The 'Transaction' document's ID
    id: ID!

    # 'Transaction' input values
    data: PartialUpdateTransactionInput!
  ): Transaction

  # Create a new document in the collection of 'Statement'
  createStatement(
    # 'Statement' input values
    data: StatementInput!
  ): Statement!

  # Delete an existing document in the collection of 'Statement'
  deleteStatement(
    # The 'Statement' document's ID
    id: ID!
  ): Statement

  # Update an existing document in the collection of 'Statement'
  updateStatement(
    # The 'Statement' document's ID
    id: ID!

    # 'Statement' input values
    data: StatementInput!
  ): Statement

  # Update an existing document in the collection of 'Transaction'
  updateTransaction(
    # The 'Transaction' document's ID
    id: ID!

    # 'Transaction' input values
    data: TransactionInput!
  ): Transaction

  # Create a new document in the collection of 'Category'
  createCategory(
    # 'Category' input values
    data: CategoryInput!
  ): Category!

  # Update an existing document in the collection of 'Category'
  updateCategory(
    # The 'Category' document's ID
    id: ID!

    # 'Category' input values
    data: CategoryInput!
  ): Category

  # Delete an existing document in the collection of 'Category'
  deleteCategory(
    # The 'Category' document's ID
    id: ID!
  ): Category

  # Create a new document in the collection of 'Transaction'
  createTransaction(
    # 'Transaction' input values
    data: TransactionInput!
  ): Transaction!

  # Partially updates an existing document in the collection of 'Statement'. It only modifies the values that are specified in the arguments. During execution, it verifies that required fields are not set to 'null'.
  partialUpdateStatement(
    # The 'Statement' document's ID
    id: ID!

    # 'Statement' input values
    data: PartialUpdateStatementInput!
  ): Statement

  # Delete an existing document in the collection of 'Transaction'
  deleteTransaction(
    # The 'Transaction' document's ID
    id: ID!
  ): Transaction
}

# 'Category' input values
input PartialUpdateCategoryInput {
  archived: Boolean
  title: String
  type: CategoryType
  externalUrl: String
  paymentFrequency: PaymentFrequency
}

# 'Statement' input values
input PartialUpdateStatementInput {
  date: String
  year: String
  transactions: StatementTransactionsRelation
}

# 'Transaction' input values
input PartialUpdateTransactionInput {
  statement: TransactionStatementRelation
  amount: Float
  category: TransactionCategoryRelation
}

# 'Statement' input values
input StatementInput {
  date: String!
  year: String!
  transactions: StatementTransactionsRelation
}

# Allow manipulating the relationship between the types 'Statement' and 'Transaction'.
input StatementTransactionsRelation {
  # Create one or more documents of type 'Transaction' and associate them with the current document.
  create: [TransactionInput]

  # Connect one or more documents of type 'Transaction' with the current document using their IDs.
  connect: [ID]

  # Disconnect the given documents of type 'Transaction' from the current document using their IDs.
  disconnect: [ID]
}

scalar Time

# Allow manipulating the relationship between the types 'Transaction' and 'Category' using the field 'Transaction.category'.
input TransactionCategoryRelation {
  # Create a document of type 'Category' and associate it with the current document.
  create: CategoryInput

  # Connect a document of type 'Category' with the current document using its ID.
  connect: ID
}

# 'Transaction' input values
input TransactionInput {
  statement: TransactionStatementRelation
  amount: Float!
  category: TransactionCategoryRelation
}

# Allow manipulating the relationship between the types 'Transaction' and 'Statement' using the field 'Transaction.statement'.
input TransactionStatementRelation {
  # Create a document of type 'Statement' and associate it with the current document.
  create: StatementInput

  # Connect a document of type 'Statement' with the current document using its ID.
  connect: ID

  # If true, disconnects this document from 'Statement'
  disconnect: Boolean
}

type Category {
  externalUrl: String

  # The document's ID.
  _id: ID!
  archived: Boolean!
  paymentFrequency: PaymentFrequency
  title: String!
  type: CategoryType!

  # The document's timestamp.
  _ts: Long!
}

# The pagination object for elements of type 'Category'.
type CategoryPage {
  # The elements of type 'Category' in this page.
  data: [Category]!

  # A cursor for elements coming after the current page.
  after: String

  # A cursor for elements coming before the current page.
  before: String
}

enum CategoryType {
  INCOME
  EXPENSE
  SAVING
}

enum PaymentFrequency {
  BIWEEKLY
  MONTHLY
  BIMONTLY
  QUARTERLY
  OTHER
}

type Query {
  allStatementsSortedByYearDesc(
    # The number of items to return per page.
    _size: Int

    # The pagination cursor.
    _cursor: String
  ): QueryAllStatementsSortedByYearDescPage!
  allCategories(
    # The number of items to return per page.
    _size: Int

    # The pagination cursor.
    _cursor: String
  ): CategoryPage!

  # Find a document from the collection of 'Category' by its id.
  findCategoryByID(
    # The 'Category' document's ID
    id: ID!
  ): Category

  # Find a document from the collection of 'Transaction' by its id.
  findTransactionByID(
    # The 'Transaction' document's ID
    id: ID!
  ): Transaction
  statementsByYear(
    # The number of items to return per page.
    _size: Int

    # The pagination cursor.
    _cursor: String
    year: String!
  ): StatementPage!
  allStatements(
    # The number of items to return per page.
    _size: Int

    # The pagination cursor.
    _cursor: String
  ): StatementPage!
  statementsByYearSortedDesc(
    # The number of items to return per page.
    _size: Int

    # The pagination cursor.
    _cursor: String
    year: String!
  ): QueryStatementsByYearSortedDescPage!

  # Find a document from the collection of 'Statement' by its id.
  findStatementByID(
    # The 'Statement' document's ID
    id: ID!
  ): Statement
  statementByDate(date: String!): Statement
}

# The pagination object for elements of type 'Statement'.
type QueryAllStatementsSortedByYearDescPage {
  # The elements of type 'Statement' in this page.
  data: [Statement]!

  # A cursor for elements coming after the current page.
  after: String

  # A cursor for elements coming before the current page.
  before: String
}

# The pagination object for elements of type 'Statement'.
type QueryStatementsByYearSortedDescPage {
  # The elements of type 'Statement' in this page.
  data: [Statement]!

  # A cursor for elements coming after the current page.
  after: String

  # A cursor for elements coming before the current page.
  before: String
}

type Statement {
  # The document's ID.
  _id: ID!
  year: String!
  date: String!
  transactions(
    # The number of items to return per page.
    _size: Int

    # The pagination cursor.
    _cursor: String
  ): TransactionPage!

  # The document's timestamp.
  _ts: Long!
}

# The pagination object for elements of type 'Statement'.
type StatementPage {
  # The elements of type 'Statement' in this page.
  data: [Statement]!

  # A cursor for elements coming after the current page.
  after: String

  # A cursor for elements coming before the current page.
  before: String
}

type Transaction {
  # The document's ID.
  _id: ID!
  statement: Statement
  amount: Float!
  category: Category!

  # The document's timestamp.
  _ts: Long!
}

# The pagination object for elements of type 'Transaction'.
type TransactionPage {
  # The elements of type 'Transaction' in this page.
  data: [Transaction]!

  # A cursor for elements coming after the current page.
  after: String

  # A cursor for elements coming before the current page.
  before: String
}

# The `Long` scalar type represents non-fractional signed whole numeric values. Long can represent values between -(2^63) and 2^63 - 1.
scalar Long
